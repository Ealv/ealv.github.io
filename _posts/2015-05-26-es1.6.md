---
layout: post
tumblr_id: 1121202947
disqus_comments: true
date: 2015-05-26 10:00:00 UTC
title: Javascript 1.6 / ES2015 Features
---

# Introduction

Il s'agit de quelques améliorations de JS 2015 aka 1.6.
Nous ne présentons que quelques fonctionnalités/syntaxes nouvelles en regard de problèmes de la version 1.5.


# Scope and Hoisting


## "Problème" : Hoisting, the scope is the function

```js
function f(){
	console.log(a);
}
```

Uncaught ReferenceError: a is not defined


### Hoisting
```js
function f(){
	console.log(a);
	var a;
}
```
undefined

Pourquoi ? les déclarations de variables avec le mot clé "var" sont déplacés en début de leurs scopes lors du pré-processing (Hoisting).


### The scope is the function 
```js
function f(){
	if(true) {
		var a;
		a = 10;
	}
	console.log(a);//return 10, the a déclaration (var a) is hoisted
}
```

##Solution/Nouveauté Javascript 1.6 : Let !


```js
function f(){
	if(true) {
		let a;
		a = 10;
	}
	console.log(a);//ReferenceError: a is not defined
}
```

##Nouveauté  : Const (let immutable) !

```js
function f(){
	const a = 10;
	a = 5; //error a is a const !
	const c = {toto : 7};
	c= {};//error b is a const !
	c.toto = 8; //ok, not a deep immutable

}
```

# Les Lambda 


## problème binding "this" !


Exemple from <a href="https://leanpub.com/understandinges6/read/" >LeanPub</a>


```js
var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type);     // error
        }, false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

## solution : les lambdas (Arrow functions)


```js

var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", 
				event =>  this.doSomething(event.type), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

# Boilerplate


## problème, initialisations...


```js
function foo(toto){
	toto = toto === undefined ? 5 : toto; //valeur par defaut 5
	var titi = 51;
	//objet literal avec param même nom que la variable
	return {
		toto : toto,
		titi : titi
	};
};

function other(){
	var res =  foo();
	//on doit récupérer les éléments qui nous intéressent de res
	var toto = res.toto;
	var titi = res.titi;
	console.log("toto is " + toto + " titi  " + titi);
}
```


## solution : destructuring, default value,...


```js
function foo(toto = 5){
	var titi = 51;
	return {toto, titi};
};


function other(){
	var {toto,titi} =  foo();
	console.log("toto is " + toto + " titi  " + titi);
}
```


## problème : dealing with arguments...


```js
function foo(){
	//arguments is not an array !
	arguments.forEach(function(elem){console.log(elem);});//undefined is not a function

	///hiiiiiii ! we must do this ugly thing to convert arguments as array:
	var args = Array.prototype.slice.call(arguments);
	args.forEach(function(elem){console.log(elem);}); //toot,15,null,{ titi: 'totot' }


};

foo("toot",15,null,{titi:"totot"});

```


## solution : with rest param !


```js
function foo(...args){
//yes args is a real array with all the built-in functions
	args.forEach(function(elem){console.log(elem);}); 	//toot,15,null,{ titi: 'totot' }
};
foo("toot",15,null,{titi:"totot"});
```

Mais on peut aussi utiliser explicitement certains params (right-Variadic)

```js
function foo(first,...args){
	console.log(first);//toot
	args.forEach(function(elem){console.log(elem);});//15,null,{ titi: 'totot' }
};
foo("toot",15,null,{titi:"totot"});
```



# Pyramid of doom, callback hell.


Javascript est single-thread et asynchrone.

Afin de ne pas bloquer <a href="http://latentflip.com/loupe/?code=!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" >l'event-loop</a> coté client 
(et aussi coté backend avec node.js) il faut pouvoir déférer les appels qui doivent être consécutifs.
C'est là où interviennent les call-back.


```js

var app = App();

app.init(function(){
	app.checkCredentials("user", "password",function(){
		//user is granted
		app.connectToDB(function(){
			//user is connected to db
			app.addUserComments("hie", function(){
				//comment "hie" is added
			});
		});
	});
}
```
La pyramide of doom c'est les multiples fermetures ""});});" en fin de fonction.
Idéalement on voudrait écrire cela :

```js
var app = App();
app.init()
	.then(checkCredentials("user", "password"))
	.then(app.connectToDB())
	.then(addUserComments("hie"));

```

C'est à dire écrire "presque" en style synchrone, mais en guardant le comportement asynchrone

.## solution promise, generator, async await ?

Beaucoup de solutions existantes autours de librairies : 
<ul>
<li><a href="https://www.npmjs.com/package/q" target="_blank">Q</a>
<li><a href="https://www.npmjs.com/package/co" target="_blank">Co</a>
<li><a href="https://www.npmjs.com/package/async" target="_blank">async (comme librairie, pas comme la fonction native JS1.7)</a>
<li><a href="https://www.npmjs.com/search?q=async" target="_blank">... et 4906 packages npm (à l'heure d'aujourd'hui) qui correspondent à async...</a>
</ul>

Mais aussi autours de solutions natives en 1.6 et ou 1.7:

<ul>
<li><a href="https://www.npmjs.com/package/q" target="_blank">Promise (1.6)</a>
<li><a href="https://www.npmjs.com/package/co" target="_blank">Générator + variable (1.6)</a>
<li><a href="https://www.npmjs.com/package/co" target="_blank">Générator + Promise(1.6)</a>
<li><a href="https://www.npmjs.com/package/co" target="_blank">Async + Await (1.7) </a>
</ul>