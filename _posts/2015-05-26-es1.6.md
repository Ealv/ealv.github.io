---
layout: post
tumblr_id: 1121202947
disqus_comments: true
date: 2015-05-26 10:00:00 UTC
title: Javascript 1.6 / ES2015 Features
---

# Introduction

Il s'agit de quelques améliorations de JS 2015 aka 1.6.
Nous ne présentons que quelques fonctionnalités/syntaxes nouvelles en regard de problèmes existants inhérent au langage.


# Scope and hoisting


## "Problème" : Hoisting, the scope is the function

```js
function f(){
	console.log(a);
}
```

Ce code renvoie : 
Uncaught 
ReferenceError: a is not defined

```js
function f(){
	console.log(a);
	var a;
}
```
Ce code renvoie : 
undefined

Pourquoi ? les déclarartions de variables aveec le mot clé var sont déplacer en début de leurs scopes lors du pré-processing (hoisting).

```js
function f(){
	if(true) {
		var a;
		a = 10;
	}
	console.log(a);//return 10, a is hoisting
}
```

##Solution/Nouveauté Javascript 1.6 : Let !


```js
function f(){
	if(true) {
		let a;
		a = 10;
	}
	console.log(a);//ReferenceError: a is not defined
}
```

##Nouveauté  : Const (let "soft" immutable) !

```js
function f(){
	const a = 10;
	a = 5; //error a is a const !
	const c = {toto : 7};
	c= {};//error b is a const !
	c.toto = 8; //ok, not a deep immutable

}
```

# Les Lambda 


## problème binding "this" !


Exemple from <a href="https://leanpub.com/understandinges6/read/" >LeanPub</a>


```js
var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type);     // error
        }, false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

## solution : les lambdas (Arrow functions)


```js

var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", 
				event =>  this.doSomething(event.type), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```




# Boilerplate


## problème, initialisations...


```js
function foo(toto){
	toto = toto || 5;
	var titi = 51;
	return {
		toto : toto,
		titi : titi
	};
};

function other(){
	var res =  foo();
	var toto = res.toto;
	var titi = res.titi;
	console.log("toto is " + toto + " titi  " + titi);
}
```


## solution destructuring default value


```js
function foo(toto = 5){
	var titi = 51;

	return {
		 toto,
		 titi
	};
};


function other(){
	var {toto,titi} =  foo();
	console.log("toto is " + toto + " titi  " + titi);
}
```



## problème, dealing with arguments ...


```js
function foo(){
	//arguments is not an array !
	arguments.forEach(function(elem){console.log(elem);});//undefined is not a function

	///we must do this ugly thing to convert :
	var args = Array.prototype.slice.call(arguments);
	args.forEach(function(elem){console.log(elem);}); //toot,15,null,{ titi: 'totot' }


};

foo("toot",15,null,{titi:"totot"});


```


## solution with rest param


```js
function foo(...args){
	args.forEach(function(elem){console.log(elem);}); 	//toot,15,null,{ titi: 'totot' }
};
foo("toot",15,null,{titi:"totot"});
```

Mais on peut aussi utiliser explicitement certains params

```js
function foo(first,...args){
	console.log(first);
	args.forEach(function(elem){console.log(elem);});
};
foo("toot",15,null,{titi:"totot"});
```



# pyramid of doom , callback hell.


Javascript est single-thread et asynchrone.


Afin de ne pas bloquer <a href="http://latentflip.com/loupe/?code=!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" >l'event-loop</a> coté client 
(et pour les mêmes raisons coté backend) il faut pouvoir defferer les appels qui diovent être consécutifs.


```js

var app = App();

app.init(function(){
	app.checkCredentials("user", "password",function(){
		//user is granted
		app.connectToDB(function(){
			//user is connected to db
			app.addUserComments("hie", function(){
				//comment "hie" is added
			});
		});
	});
}
```


## solution promise, generator, async await ?


Beaucoup de solutions existantes autours de librairies : 
-Q
-Co