---
layout: post
tumblr_id: 1121202947
disqus_comments: true
date: 2015-05-26 10:00:00 UTC
title: Javascript 1.6 / ES2015 Features
---



# Scope and hoisting


## "Problème" : Hoisting, the scope is the function

```js
function f(){
	console.log(a);
}
```

Ce code renvoie : 
Uncaught 
ReferenceError: a is not defined

```js
function f(){
	console.log(a);
	var a;
}
```
Ce code renvoie : 
undefined

Pourquoi ? les déclarartions de variables aveec le mot clé var sont déplacer en début de leurs scopes lors du pré-processing (hoisting).

```js
function f(b){
	if(true) {
		var a;
		a = 10;
	}
	console.log(a);//return 10, a is hoisting
}
```

##Solution/Nouveauté Javascript 1.6 : Let !


```js
function f(b){
	if(true) {
		let a;
		a = 10;
	}
	console.log(a);//ReferenceError: a is not defined
}
```

##Nouveauté  : Const !

```js
function f(b){
	const a = 10;
	a = 5; //error a is a const !
	const b = {toto : 7};
	b= {};//error b is a const !
	b.toto = 8; //ok, not a deep immutable

}
```

# Les Lambda 


## problème binding "this" !


Exemple from <a href="https://leanpub.com/understandinges6/read/" >LeanPub</a>


```js
var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type);     // error
        }, false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```

## solution : les lambdas (Arrow functions)


```js

var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", 
				event =>  this.doSomething(event.type), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
```




# Boilerplate


## problème, initialisations...


```js
function foo(toto){
	toto = toto || 5;
	var titi = 51;
	return {
		toto : toto,
		titi : titi
	};
};

function other(){
	var res =  foo();
	var toto = res.toto;
	var titi = res.titi;
	console.log("toto is " + toto + " titi  " + titi);
}
```


## solution destructuring default value


```js
function foo(toto = 5){
	var titi = 51;

	return {
		 toto,
		 titi
	};
};


function other(){
	var {toto,titi} =  foo();
	console.log("toto is " + toto + " titi  " + titi);
}
```



## problème, dealing with arguments ...


```js
function foo(){
	//arguments is not an array !
	arguments.forEach(function(elem){console.log(elem);});//undefined is not a function

	///we must do this ugly thing to convert :
	var args = Array.prototype.slice.call(arguments);
	args.forEach(function(elem){console.log(elem);}); //toot,15,null,{ titi: 'totot' }


};

foo("toot",15,null,{titi:"totot"});


```


## solution with rest param


```js
function foo(...args){
	args.forEach(function(elem){console.log(elem);}); 	//toot,15,null,{ titi: 'totot' }
};
foo("toot",15,null,{titi:"totot"});
```

Mais on peut aussi utiliser explicitement certains params

```js
function foo(first,...args){
	console.log(first);
	args.forEach(function(elem){console.log(elem);});
};
foo("toot",15,null,{titi:"totot"});
```